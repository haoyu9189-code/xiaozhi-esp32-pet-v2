# 小智记忆系统架构说明

## 一、系统概述

小智的记忆系统采用**多层次结构化存储**，支持用户信息、日程管理、情感记录等功能，为宠物AI提供长期记忆能力。

### 核心特性
- ✅ **持久化存储**：基于 ESP32 NVS（非易失性存储）
- ✅ **结构化数据**：9大类记忆类型，支持48KB存储空间
- ✅ **深层记忆归档**：独立Memory分区（3MB）存储长期历史记忆
- ✅ **智能检索**：支持按时间范围、关键词、最近N条三种检索方式
- ✅ **智能提取**：从对话中自动提取关键信息
- ✅ **日程管理**：支持单次/重复日程，自动提醒，冲突检测
- ✅ **情感建模**：追踪亲密度、情绪、关系阶段
- ✅ **MCP工具接口**：通过MCP工具与AI对话系统集成

---

## 二、架构层次

```
┌─────────────────────────────────────────────────────────┐
│                   AI 对话系统 (Claude)                    │
│              通过 MCP 工具访问记忆系统                     │
└─────────────────┬───────────────────────────────────────┘
                  │ MCP Tools API
                  ▼
┌─────────────────────────────────────────────────────────┐
│              Memory MCP Tools Layer                      │
│  • memory(read/write/delete/...)                        │
│  • 日程管理 (schedule/complete_schedule/...)            │
│  • 深层检索 (recall: 时间范围/关键词/最近N条)           │
│  • 智能提取器调用                                        │
└─────────────────┬───────────────────────────────────────┘
                  │
      ┌───────────┼───────────┬───────────┐
      ▼           ▼           ▼           ▼
┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐
│  Memory  │ │  Memory  │ │ Pending  │ │  Memory  │
│ Storage  │ │Extractor │ │  Memory  │ │ Archive  │
│(浅层记忆)│ │(智能提取)│ │(待处理)  │ │(深层记忆)│
│          │ │          │ │          │ │归档+检索 │
└────┬─────┘ └──────────┘ └──────────┘ └────┬─────┘
     │                                        │
     ▼                                        ▼
┌────────────────┐                  ┌────────────────┐
│   NVS Flash    │                  │Memory (SPIFFS) │
│   (48KB)       │                  │   (3MB)        │
│  热数据/30天   │                  │ 冷数据/归档    │
└────────────────┘                  └────────────────┘
```

---

## 三、核心模块

### 3.1 Memory Storage（存储层）
**文件位置**：`main/memory/memory_storage.{h,cc}`

**职责**：
- 管理所有记忆数据的持久化存储
- 提供 CRUD 接口
- 内存缓存 + 脏标记机制优化性能
- 自动清理过期数据

**数据结构（浅层记忆 - NVS）**：
| 类型 | 最大数量 | 单条大小 | 归档策略 | 说明 |
|------|----------|----------|---------|------|
| UserProfile | 1 | 79B | 不归档 | 用户档案（姓名、生日、年龄等） |
| FamilyMember | 8 | 130B | 不归档 | 家庭成员 |
| Preferences | 16 | 530B | 不归档 | 喜好（8个喜欢+8个不喜欢） |
| Event | 16 | 106B | 已过事件归档 | 事件/日程 |
| Fact | 20 | 132B | ✅ **滚动归档** | 事实记录（超过20条自动归档最早的） |
| Trait | 10 | 64B | 不归档 | 性格特征 |
| Habit | 10 | 64B | 不归档 | 习惯 |
| SpecialMoment | 10 | 168B | ✅ **滚动归档** | 特殊时刻（超过10条自动归档最早的） |
| PersonalGoal | 5 | 80B | 不归档 | 个人目标 |
| ChatMessage | 30 | 100B | 计划中 | 聊天记录 |

**深层记忆归档（Asset/SPIFFS - 8MB）**：
- Facts 归档：`/spiffs/memory/facts_archive.jsonl`
- Moments 归档：`/spiffs/memory/moments_archive.jsonl`
- Events 归档：`/spiffs/memory/events_archive.jsonl`
- 格式：JSONL（每行一条 JSON 记录）
- 容量：可存储约 3 年历史记忆（~6MB）

**关键方法**：
```cpp
// 档案管理
int GetProfile(UserProfile* profile);
AUDNAction UpdateProfile(...);

// 偏好管理
AUDNAction AddPreference(const char* item, bool is_like);

// 事件管理
int GetEvents(Event* events, int max_count);
AUDNAction AddEvent(...);

// 日程管理
bool AddEvent(const Event& event);
std::vector<Event> GetUpcomingSchedules(int minutes_ahead);
bool MarkScheduleReminded(const std::string& content);
void GenerateNextRepeatSchedule(const Event& completed_event);
ConflictInfo CheckScheduleConflict(const char* date, const char* time, int duration_minutes = 60);
```

**深层记忆归档（自动触发）**：
- Facts 超过 20 条时，自动归档最早的记录
- Moments 超过 10 条时，自动归档最早的记录
- 归档到 `/spiffs/memory/` 目录的 JSONL 文件

### 3.2 Memory Types（类型定义层）
**文件位置**：`main/memory/memory_types.h`

**职责**：
- 定义所有记忆数据结构
- 定义枚举类型（情绪、重要性、关系阶段等）
- 提供辅助宏和内联函数

**关键枚举**：
```cpp
// 情绪类型
enum class EmotionType {
    NEUTRAL, HAPPY, SAD, EXCITED, WORRIED, TOUCHED
};

// 重要性级别
enum class SignificanceLevel {
    LOW = 1, MEDIUM, HIGH, VERY_HIGH, CRITICAL
};

// 关系阶段（基于total_coins_spent）
enum class RelationshipStage {
    STRANGER = 0,       // 0-20 金币
    ACQUAINTANCE = 1,   // 21-50 金币
    FRIEND = 2,         // 51-100 金币
    CLOSE_FRIEND = 3,   // 101-200 金币
    SOULMATE = 4        // 201+ 金币
};

// 操作结果
enum class AUDNAction {
    ADDED, UPDATED, DELETED, NOOP
};
```

**Event 结构扩展**：
```cpp
struct Event {
    char date[11];           // YYYY-MM-DD 或 MM-DD
    char time[6];            // HH:MM（日程时间）
    char event_type[16];
    char content[64];
    uint8_t reminded;        // 是否已提醒
    EmotionalContext emotion;
    uint8_t significance;
    uint8_t flags;           // 位字段标志
    uint8_t repeat_interval;
};

// 标志位定义
#define EVENT_FLAG_IS_SCHEDULE  0x01  // 是否为日程
#define EVENT_FLAG_COMPLETED    0x02  // 是否已完成
#define REPEAT_NONE             0x00  // 不重复
#define REPEAT_DAILY            0x04  // 每日重复
#define REPEAT_WEEKLY           0x08  // 每周重复
#define REPEAT_MONTHLY          0x0C  // 每月重复
```

### 3.3 Memory Extractor（智能提取层）
**文件位置**：`main/memory/memory_extractor.{h,cc}`

**职责**：
- 从对话中自动提取关键信息
- 支持提取：身份信息、偏好、家庭、事件、事实

**提取类型**：
```cpp
enum class ExtractedType {
    NONE,
    IDENTITY,    // 姓名、年龄、性别、地点
    PREFERENCE,  // 喜好/厌恶
    FAMILY,      // 家庭成员
    EVENT,       // 事件/计划
    FACT         // 一般事实
};
```

**工作流程**：
1. 监听对话消息
2. 使用规则/AI提取关键信息
3. 生成 `ExtractedMemory` 结构
4. 写入 `PendingMemory` 待处理队列
5. 后台批量写入 `MemoryStorage`

### 3.4 Pending Memory（待处理队列）
**文件位置**：`main/memory/pending_memory.{h,cc}`

**职责**：
- 临时存储待写入的记忆
- 批量处理，减少NVS写入频率
- 避免对话过程中阻塞

**使用场景**：
- 对话中提取到新信息 → 加入队列
- 对话结束时 → 批量持久化到NVS

### 3.5 Memory MCP Tools（MCP工具层）
**文件位置**：`main/memory/memory_mcp_tools.{h,cc}`

**职责**：
- 提供 MCP 工具接口供 AI 调用
- 连接 AI 系统和记忆存储

**核心MCP工具**：

#### **memory** 工具
```javascript
{
  name: "memory",
  description: "管理用户记忆（档案、偏好、家庭、事件等）",
  inputSchema: {
    action: "read|write|delete|complete_schedule",
    type: "name|age|gender|location|like|dislike|family|...",
    content: "内容",
    datetime: "YYYY-MM-DD HH:MM",  // 日程用
    repeat: "none|daily|weekly|monthly"  // 重复类型
  }
}
```

**动作说明**：

| Action | 说明 | 示例 |
|--------|------|------|
| `read` | 读取所有记忆 | 对话开场必调用，获取用户信息 |
| `write` | 写入/更新记忆 | 记录用户姓名、爱好、家人等 |
| `delete` | 删除记忆 | 删除错误信息 |
| `complete_schedule` | 完成日程 | 标记日程为已完成 |

**使用示例**：

```python
# 1. 开场读取记忆（获取亲密度）
memory(action="read")
# 返回：profile, preferences, family, facts, schedules, total_coins_spent

# 2. 记录用户姓名
memory(action="write", type="name", content="王浩宇")

# 3. 添加喜好
memory(action="write", type="like", content="打篮球")

# 4. 添加家庭成员
memory(action="write", type="family",
       relation="妈妈", name="李娟", closeness=5)

# 5. 添加单次日程
memory(action="write", type="schedule",
       content="团队会议", datetime="2026-02-05 14:00")

# 6. 添加重复日程
memory(action="write", type="schedule",
       content="每天早餐提醒", datetime="2026-02-05 08:00",
       repeat="daily")

# 7. 完成日程
memory(action="complete_schedule", content="团队会议")

# 8. 删除日程
memory(action="delete", type="schedule", content="团队会议")
```

### 3.6 Memory Archive（深层记忆归档）
**文件位置**：`main/memory/memory_archive.{h,cc}`

**职责**：
- 管理长期记忆的归档存储（独立 Memory 分区/SPIFFS）
- 自动归档超过30天的 Facts/Moments
- 支持归档检索功能（阶段2 - 未来实现）

**存储架构**：
| 存储层 | 介质 | 容量 | 访问速度 | 用途 |
|--------|------|------|---------|------|
| **浅层记忆** | NVS | 48KB | 快速 | 热数据（30天内） |
| **深层记忆** | Memory 分区 (SPIFFS) | 3MB ⭐ 独立分区 | 中等 | 冷数据（30天外归档） |

**归档策略**：
| 数据类型 | 归档时机 | 归档条件 | 保留在NVS |
|---------|---------|---------|----------|
| Facts | 每日凌晨 | 创建时间>30天 | 30天内的 |
| Moments | 每日凌晨 | 创建时间>30天 | 30天内的 |
| Events | 每周日 | 纪念日已过 | 未来事件 |

**存储格式**（JSONL）：
```
/spiffs/memory/
  ├── facts_archive.jsonl       # 事实归档
  ├── moments_archive.jsonl    # 时刻归档
  └── events_archive.jsonl     # 事件归档
```

**核心方法**：
```cpp
// 初始化（挂载SPIFFS）
bool Init();

// 归档接口
bool ArchiveFacts(const std::vector<Fact>& facts);
bool ArchiveMoments(const std::vector<SpecialMoment>& moments);
bool ArchiveEvents(const std::vector<Event>& events);

// 统计
size_t GetArchiveCount(const char* type);

// 阶段2（未来实现）
// std::vector<ArchivedItem> RecallByTimeRange(...);
// std::vector<ArchivedItem> RecallByKeyword(...);
```

**预期效果**：
- NVS占用始终保持在 <30%（约12KB）
- Asset可存储3年以上历史记忆（约6MB）
- 历史记忆不再丢失

---

## 四、日程管理系统

### 4.1 日程类型
- **单次日程**：指定日期和时间，一次性事件
- **重复日程**：支持每日/每周/每月重复

### 4.2 日程状态
- `reminded = 0`：未提醒
- `reminded = 1`：已提醒（系统每10分钟自动检查即将到来的日程）
- `completed = 1`：已完成

### 4.3 重复日程机制
**完成流程**：
1. 用户调用 `complete_schedule`
2. 标记当前日程为已完成
3. 自动生成下一次重复日程（如果是重复类型）
4. 新日程的 `reminded = 0`，`completed = 0`

**生成规则**：
- `REPEAT_DAILY`：当前日期 + 1天
- `REPEAT_WEEKLY`：当前日期 + 7天
- `REPEAT_MONTHLY`：当前日期 + 1个月（同日期）

### 4.4 提醒逻辑
**文件位置**：`main/memory/memory_storage.cc:GetUpcomingSchedules()`

```cpp
std::vector<Event> GetUpcomingSchedules(int minutes_ahead = 60) {
    // 返回未提醒的、即将到来的日程（1小时内）
    // 系统每10分钟自动调用一次
}
```

**提醒优先级**（基于 `priority` 字段）：
- **高优先级 (4-5)**：紧急重要，特别强调
- **中等优先级 (3)**：正常提醒
- **低优先级 (1-2)**：简单提及

**AI提醒示例**：
```python
# 高优先级
"重要！你下午2点有个紧急会议"

# 中等优先级
"哎对了，你下午2点有个会议哦"

# 低优先级
"对了，你今天还有个健身计划"
```

---

## 五、亲密度系统

### 5.1 关系阶段判定
**依据**：`total_coins_spent`（累计花费金币数）

```cpp
enum class RelationshipStage {
    STRANGER = 0,       // 0-20 金币：陌生期
    ACQUAINTANCE = 1,   // 21-50 金币：熟悉期
    FRIEND = 2,         // 51-100 金币：亲密期
    CLOSE_FRIEND = 3,   // 101-200 金币：深厚期
    SOULMATE = 4        // 201+ 金币：灵魂伴侣
};
```

### 5.2 AI行为调整
**system_prompt.txt 中的指导**：
- 每次对话开始调用 `memory(action="read")`
- 根据 `total_coins_spent` 严格调整说话方式
- 陌生期：客气生疏，叫"主人"/"您"
- 熟悉期：自然些，叫"你"，偶尔撒娇
- 亲密期：放松随意，开玩笑
- 深厚期：信任依赖，说心事
- 灵魂伴侣：完全放松，有默契梗

---

## 六、数据流示例

### 6.1 对话开场流程
```
1. AI系统启动对话
   ↓
2. 调用 memory(action="read")
   ↓
3. MemoryMcpTools::BuildReadResponse()
   ↓
4. MemoryStorage 读取缓存/NVS
   ↓
5. 返回 JSON：
   {
     "profile": {"name": "王浩宇", "age": 25, ...},
     "preferences": {"likes": ["篮球"], "dislikes": [...]},
     "family": [{"relation": "妈妈", "name": "李娟", ...}],
     "facts": ["..."],
     "schedules": [
       {"content": "团队会议", "datetime": "2026-02-05 14:00",
        "reminded": 0, "priority": 4}
     ],
     "total_coins_spent": 35
   }
   ↓
6. AI判断：total_coins_spent=35 → ACQUAINTANCE阶段
   ↓
7. AI调整说话方式："你好呀，今天过得怎么样？"（熟悉期）
   ↓
8. AI提醒日程："哎对了，你明天下午2点有个重要会议哦"
```

### 6.2 添加日程流程
```
用户说："明天下午2点有个会议，记一下"
   ↓
AI理解并调用：
memory(action="write", type="schedule",
       content="团队会议", datetime="2026-02-05 14:00")
   ↓
MemoryMcpTools 解析参数
   ↓
创建 Event 结构：
{
  date: "2026-02-05",
  time: "14:00",
  content: "团队会议",
  flags: EVENT_FLAG_IS_SCHEDULE,
  reminded: 0,
  completed: 0,
  repeat_type: REPEAT_NONE
}
   ↓
MemoryStorage::AddEvent() 写入NVS
   ↓
返回成功："好的，已经帮你记下明天下午2点的会议啦"
```

### 6.3 重复日程完成流程
```
用户说："我吃完早餐了"
   ↓
AI调用：memory(action="complete_schedule", content="每天早餐提醒")
   ↓
MemoryStorage::MarkScheduleCompleted()
   ↓
1. 找到匹配的日程
2. 标记 completed = 1
3. 检查 repeat_type = REPEAT_DAILY
   ↓
4. GenerateNextRepeatSchedule()
   - 当前日期：2026-02-05
   - 新日期：2026-02-06
   - 创建新 Event：
     {
       date: "2026-02-06",
       time: "08:00",
       content: "每天早餐提醒",
       repeat_type: REPEAT_DAILY,
       reminded: 0,
       completed: 0
     }
   ↓
5. 保存到NVS
   ↓
返回："好的记录啦！明天早上8点我再提醒你哦"
```

---

## 七、存储优化

### 7.1 缓存机制
- **内存缓存**：所有数据类型都有对应的 `*_cache_`
- **懒加载**：首次访问时从NVS加载到缓存
- **脏标记**：修改时标记 `*_dirty_ = true`
- **批量写入**：`Flush()` 时统一写回NVS

### 7.2 空间管理
**总容量**：48KB NVS分区

**预估占用**：
```
UserProfile:      79B  × 1  = 79B
FamilyMember:    130B  × 8  = 1040B
Preferences:     530B  × 1  = 530B
Event:           106B  × 16 = 1696B
Fact:            132B  × 20 = 2640B
Trait:            64B  × 10 = 640B
Habit:            64B  × 10 = 640B
SpecialMoment:   168B  × 10 = 1680B
PersonalGoal:     80B  × 5  = 400B
ChatMessage:     100B  × 30 = 3000B
AffectionStats:   48B  × 1  = 48B
-------------------------------------
总计：约 12.3KB / 48KB (25.6%)
```

### 7.3 自动清理
```cpp
void AutoCleanCompletedSchedules() {
    // 删除已完成且非重复的旧日程
    // 保留重复日程和近期日程
}
```

---

## 八、MCP工具注册

**文件位置**：`main/memory/memory_mcp_tools.cc:RegisterMemoryMcpTools()`

```cpp
void RegisterMemoryMcpTools(McpServer& mcp_server) {
    // 注册 memory 工具
    mcp_server.AddTool("memory",
        "管理用户记忆（档案、偏好、家庭、事件、日程等）",
        schema, handler);
}
```

**调用路径**：
```
application.cc:Initialize()
    ↓
RegisterAllMcpTools(mcp_server)
    ↓
RegisterMemoryMcpTools(mcp_server)
    ↓
MCP Server 注册工具
    ↓
AI可通过 MCP 协议调用
```

---

## 九、错误处理

### 9.1 返回值规范
```cpp
enum class AUDNAction {
    ADDED,    // 成功添加新记录
    UPDATED,  // 成功更新已有记录
    DELETED,  // 成功删除记录
    NOOP      // 无变化（重复/不存在）
};
```

### 9.2 日志级别
- **ESP_LOGI**：正常操作（添加、更新、删除）
- **ESP_LOGW**：警告（重复添加、未找到）
- **ESP_LOGE**：错误（NVS写入失败、参数错误）

---

## 十、未来扩展方向

### 10.1 已实现功能 ✅
- [x] 基础记忆存储（9大类）
- [x] 日程管理（单次/重复）
- [x] 自动提醒机制
- [x] 亲密度系统
- [x] MCP工具集成
- [x] 智能信息提取

### 10.2 可扩展方向 🚀
- [ ] **记忆搜索优化**：关键词索引、模糊匹配
- [ ] **长期记忆压缩**：旧记忆自动摘要
- [ ] **记忆关联图谱**：构建知识图谱
- [ ] **情感分析增强**：更细粒度的情绪识别
- [ ] **跨设备同步**：云端备份和同步
- [ ] **记忆可视化**：Web界面查看记忆时间线

---

## 十一、关键文件清单

| 文件路径 | 行数 | 说明 |
|---------|------|------|
| `main/memory/memory_types.h` | 310 | 数据结构定义 |
| `main/memory/memory_storage.h` | 158 | 存储接口定义 |
| `main/memory/memory_storage.cc` | ~2000 | 存储实现 |
| `main/memory/memory_mcp_tools.h` | 10 | MCP工具接口 |
| `main/memory/memory_mcp_tools.cc` | 624 | MCP工具实现 |
| `main/memory/memory_extractor.h` | ~100 | 智能提取接口 |
| `main/memory/memory_extractor.cc` | ~300 | 智能提取实现 |
| `main/memory/pending_memory.h` | ~50 | 待处理队列 |
| `main/memory/pending_memory.cc` | ~200 | 队列实现 |
| `system_prompt.txt` | 56 | AI使用指南 |

---

## 十二、开发注意事项

### 12.1 NVS写入优化
- **避免频繁写入**：使用缓存和脏标记
- **批量操作**：对话结束时统一 `Flush()`
- **错误恢复**：NVS损坏时自动重建

### 12.2 日程提醒时机
- **系统定时检查**：每10分钟（在 `application.cc` 中）
- **提前量**：提前1小时提醒
- **去重**：已提醒的日程不再重复提醒

### 12.3 线程安全
```cpp
std::mutex mutex_;  // MemoryStorage 内部使用互斥锁保护
```

---

## 附录：完整的MCP工具Schema

```json
{
  "name": "memory",
  "description": "管理用户记忆，包括档案、偏好、家庭、事件、日程等",
  "inputSchema": {
    "type": "object",
    "properties": {
      "action": {
        "type": "string",
        "enum": ["read", "write", "delete", "complete_schedule"],
        "description": "操作类型"
      },
      "type": {
        "type": "string",
        "enum": [
          "name", "age", "gender", "location", "birthday",
          "like", "dislike",
          "family",
          "fact", "trait", "habit", "moment", "goal",
          "schedule"
        ],
        "description": "记忆类型"
      },
      "content": {
        "type": "string",
        "description": "内容"
      },
      "datetime": {
        "type": "string",
        "description": "日程时间（YYYY-MM-DD HH:MM）"
      },
      "repeat": {
        "type": "string",
        "enum": ["none", "daily", "weekly", "monthly"],
        "description": "重复类型"
      },
      "priority": {
        "type": "integer",
        "minimum": 1,
        "maximum": 5,
        "description": "优先级（1-5）"
      }
    },
    "required": ["action"]
  }
}
```

---

## 十二、深层记忆归档系统 (Memory Archive)

### 12.1 概述

深层记忆归档系统用于存储超出 NVS 容量限制的历史记忆，实现长期记忆保留能力。

**核心特性**：
- ✅ **独立存储分区**：使用独立的 3MB Memory 分区（SPIFFS）
- ✅ **自动归档**：Facts 超过 20 条、Moments 超过 10 条时自动归档最旧的数据
- ✅ **JSONL 格式**：每行一个 JSON 对象，支持增量追加
- ✅ **智能检索**：支持按时间范围、关键词、最近N条三种检索方式

### 12.2 文件结构

**头文件**：[main/memory/memory_archive.h](main/memory/memory_archive.h)
**实现文件**：[main/memory/memory_archive.cc](main/memory/memory_archive.cc)
**分区配置**：[partitions/v2/16m_c3.csv](partitions/v2/16m_c3.csv)

### 12.3 数据结构

#### ArchivedItem 结构（检索结果）

```cpp
struct ArchivedItem {
    char timestamp[20];    // ISO 8601 格式：YYYY-MM-DDTHH:MM:SS
    char type[16];         // fact, moment, event
    char content[256];     // JSON 序列化的完整内容
};
```

### 12.4 归档文件格式

**文件路径**：
- Facts: `/spiffs/memory/facts_archive.jsonl`
- Moments: `/spiffs/memory/moments_archive.jsonl`
- Events: `/spiffs/memory/events_archive.jsonl`

**JSONL 格式示例**（Facts）：

```jsonl
{"timestamp":"2026-01-15T10:30:00","type":"fact","content":"主人喜欢吃北京烤鸭"}
{"timestamp":"2026-01-16T14:20:00","type":"fact","content":"主人的生日是3月15日"}
{"timestamp":"2026-01-17T09:00:00","type":"fact","content":"主人在北京工作"}
```

**JSONL 格式示例**（Moments）：

```jsonl
{"timestamp":"2026-01-18T20:00:00","type":"moment","topic":"生日聚会","content":"主人和朋友们一起庆祝生日","emotion_type":1,"emotion_intensity":4,"importance":4}
{"timestamp":"2026-01-20T16:30:00","type":"moment","topic":"项目成功","content":"主人完成了重要项目","emotion_type":1,"emotion_intensity":5,"importance":5}
```

### 12.5 核心方法

#### Stage 1: 归档操作

```cpp
// 归档 Facts（当数量超过 20 时自动调用）
bool ArchiveFacts(const std::vector<Fact>& facts);

// 归档 Moments（当数量超过 10 时自动调用）
bool ArchiveMoments(const std::vector<SpecialMoment>& moments);

// 归档 Events
bool ArchiveEvents(const std::vector<Event>& events);

// 获取归档数量
size_t GetArchiveCount(const char* type);  // type: "fact", "moment", "event"
```

#### Stage 2: 检索操作

```cpp
// 按时间范围检索
std::vector<ArchivedItem> RecallByTimeRange(
    const char* type,           // fact/moment/event
    const char* start_date,     // YYYY-MM-DD (可为空)
    const char* end_date,       // YYYY-MM-DD (可为空)
    int limit = 10              // 最多返回条数
);

// 按关键词检索（不区分大小写）
std::vector<ArchivedItem> RecallByKeyword(
    const char* type,           // fact/moment/event
    const char* keyword,        // 搜索关键词
    int limit = 10              // 最多返回条数
);

// 检索最近N条归档
std::vector<ArchivedItem> RecallRecent(
    const char* type,           // fact/moment/event
    int limit = 10              // 最多返回条数
);
```

### 12.6 MCP 工具集成

#### recall 操作

**action**: `recall`
**参数**：
- `type` (必须): fact / moment / event
- `keyword` (可选): 搜索关键词
- `start_date` (可选): 起始日期 YYYY-MM-DD
- `end_date` (可选): 结束日期 YYYY-MM-DD
- `limit` (可选): 返回条数，默认 10

#### 使用示例

**1. 按关键词检索**

```python
memory(action='recall', type='fact', keyword='北京')
```

**返回示例**：

```json
{
  "type": "fact",
  "count": 2,
  "items": [
    {
      "timestamp": "2026-01-15T10:30:00",
      "type": "fact",
      "content": "主人喜欢吃北京烤鸭"
    },
    {
      "timestamp": "2026-01-17T09:00:00",
      "type": "fact",
      "content": "主人在北京工作"
    }
  ]
}
```

**2. 按时间范围检索**

```python
memory(action='recall', type='moment', start_date='2025-01-01', end_date='2025-12-31')
```

**返回示例**：

```json
{
  "type": "moment",
  "count": 3,
  "items": [
    {
      "timestamp": "2025-03-15T18:00:00",
      "type": "moment",
      "topic": "生日庆祝",
      "content": "主人25岁生日聚会",
      "emotion_type": 1,
      "emotion_intensity": 5,
      "importance": 5
    }
  ]
}
```

**3. 检索最近归档**

```python
memory(action='recall', type='fact', limit=20)
```

**返回最近归档的 20 条 Facts**

### 12.7 自动归档流程

```
1. MemoryStorage 检测到 Facts 数量 >= 20
   ↓
2. 取出最旧的 5 条 Facts
   ↓
3. 调用 MemoryArchive::ArchiveFacts(old_facts)
   ↓
4. 将 5 条 Facts 序列化为 JSONL 格式
   ↓
5. 追加到 /spiffs/memory/facts_archive.jsonl
   ↓
6. 从 NVS 中删除这 5 条 Facts，释放空间
```

**归档触发条件**：
- Facts: 20 条 → 归档最旧的 5 条
- Moments: 10 条 → 归档最旧的 3 条

### 12.8 检索性能优化

**优化策略**：
- ✅ **流式读取**：逐行读取 JSONL 文件，避免一次性加载全部内容
- ✅ **提前终止**：达到 limit 数量后立即停止扫描
- ✅ **时间戳排序**：JSONL 是追加格式，时间戳天然有序
- ✅ **关键词优化**：不区分大小写的子串匹配

**性能指标**（估算）：
- 归档 1000 条记录：约 500KB，扫描时间 < 100ms
- 关键词搜索：平均 50ms
- 时间范围检索：平均 30ms

### 12.9 存储容量规划

| 使用时长 | Facts 归档 | Moments 归档 | 预估总大小 | 剩余空间 |
|---------|-----------|-------------|-----------|---------|
| 3 个月  | ~1000 条  | ~500 条     | ~500 KB   | 2.5 MB  |
| 1 年    | ~4000 条  | ~2000 条    | ~2 MB     | 1 MB    |
| 3 年    | ~12000 条 | ~6000 条    | ~6 MB     | ⚠️ 需扩容 |

**3 年后扩容方案**：
- 删除最早的归档（保留最近 2 年）
- 压缩归档文件（gzip）
- 扩大 Memory 分区（牺牲 ota_1 空间）

### 12.10 System Prompt 使用说明

**添加到 system_prompt.txt** 的内容：

```text
- 主人问旧事/想回忆：调用memory的recall查询归档记忆
  * 按关键词：memory(action='recall', type='fact', keyword='北京') - 搜索包含"北京"的旧事实
  * 按时间：memory(action='recall', type='moment', start_date='2025-01-01', end_date='2025-12-31') - 查询2025年的特殊时刻
  * 最近归档：memory(action='recall', type='fact', limit=20) - 获取最近归档的20条事实
  * 支持类型：fact（事实）、moment（特殊时刻）、event（重要事件）
  * 用法：主人说"记得我们以前聊过什么吗"、"你还记得我去北京的事吗"、"去年的事你还记得吗"等，就用recall查询归档
```

### 12.11 实现细节

#### 辅助函数

```cpp
// 获取归档文件路径
const char* GetArchiveFilename(const char* type);

// 解析 JSONL 行为 ArchivedItem
bool ParseArchivedItem(const char* json_line, ArchivedItem& item);

// 时间范围匹配（字符串比较，利用 ISO 8601 排序特性）
bool MatchesTimeRange(const char* timestamp, const char* start_date, const char* end_date);

// 关键词匹配（不区分大小写）
bool ContainsKeyword(const char* content, const char* keyword);
```

#### 错误处理

- 归档文件不存在：返回空结果，记录 INFO 日志
- 解析失败：跳过该行，继续扫描下一行
- 磁盘空间不足：记录 ERROR 日志，归档失败

### 12.12 测试验证

#### 归档测试

```cpp
// 添加超过 20 条 Facts 触发归档
for (int i = 0; i < 25; i++) {
    memory(action='write', type='fact', content='测试事实' + i, force=true);
}
```

**预期日志**：

```
I (xxx) MemArchive: Archived 5 facts to /spiffs/memory/facts_archive.jsonl
```

#### 检索测试

```cpp
// 按关键词检索
memory(action='recall', type='fact', keyword='测试');

// 按时间检索
memory(action='recall', type='fact', start_date='2026-02-01', end_date='2026-02-28');

// 检索最近10条
memory(action='recall', type='fact', limit=10);
```

**预期返回**：包含匹配项的 JSON 结果

### 12.13 已知限制

- SPIFFS 不支持目录，使用文件名中的 "/" 模拟目录结构
- JSONL 文件追加性能优秀，但修改/删除需要重写整个文件
- 单行最大长度 512 字节（超出会被截断）
- 不支持事务性操作（归档过程中断电可能导致部分数据丢失）

### 12.14 未来扩展

- [ ] **压缩归档**：使用 gzip 压缩旧归档文件
- [ ] **分页检索**：支持 offset 参数，实现分页加载
- [ ] **模糊搜索**：支持拼音、同义词搜索
- [ ] **统计分析**：归档数据的时间分布、关键词频率统计
- [ ] **导出功能**：导出归档为 JSON/CSV 格式

---

**文档版本**：v2.0
**最后更新**：2026-02-02
**新增内容**：深层记忆归档系统 (Stage 2: Recall)
**维护者**：Claude Code Agent
