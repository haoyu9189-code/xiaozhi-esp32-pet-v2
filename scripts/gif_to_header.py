#!/usr/bin/env python3
"""
GIF to C Header Converter
将GIF文件转换为C语言头文件，用于嵌入到ESP32固件中

使用方法:
    python gif_to_header.py                    # 使用默认路径
    python gif_to_header.py -i gif_folder -o output.h
"""

import argparse
import glob
import os
import sys

# 获取脚本所在目录的父目录（项目根目录）
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
PROJECT_ROOT = os.path.dirname(SCRIPT_DIR)

# 默认路径配置
DEFAULT_INPUT_DIR = os.path.join(PROJECT_ROOT, "gif")
DEFAULT_OUTPUT_DIR = os.path.join(PROJECT_ROOT, "main", "boards")

# 表情别名映射 (保持与原otto_emoji代码兼容)
# 格式: "别名" -> "实际的表情文件名(小写)"
EMOTION_ALIASES = {
    # 原otto_emoji中使用的名称 -> 新的expressions文件名
    "staticstate": "neutral",
    "idle": "neutral",
    "anger": "angry",
    "scare": "surprised",
    "buxue": "thinking",
}


def gif_to_c_array(gif_path: str, var_name: str) -> tuple[str, int]:
    """将GIF文件转换为C数组"""
    with open(gif_path, 'rb') as f:
        data = f.read()

    if data[:3] != b'GIF':
        print(f"警告: {gif_path} 可能不是有效的GIF文件")

    size = len(data)

    # 每16个字节换行
    lines = []
    bytes_list = [f'0x{byte:02x}' for byte in data]
    for i in range(0, len(bytes_list), 16):
        lines.append('    ' + ', '.join(bytes_list[i:i+16]))

    array_content = ',\n'.join(lines)

    c_code = f'''// {os.path.basename(gif_path)} - {size} bytes
static const uint8_t {var_name}_data[] = {{
{array_content}
}};
'''
    return c_code, size


def generate_expressions_header(gif_dir: str, output_path: str):
    """生成表情GIF头文件 (兼容原otto_emoji_gif.h格式)"""

    expressions_dir = os.path.join(gif_dir, "expressions")
    if not os.path.isdir(expressions_dir):
        print(f"错误: expressions目录不存在 - {expressions_dir}")
        return False

    gif_files = glob.glob(os.path.join(expressions_dir, "*.gif"))
    gif_files += glob.glob(os.path.join(expressions_dir, "*.GIF"))

    if not gif_files:
        print(f"错误: 在 {expressions_dir} 中没有找到GIF文件")
        return False

    header_content = '''#pragma once

#include <stdint.h>
#include <stddef.h>

// Auto-generated expressions GIF data
// Generated by gif_to_header.py

'''

    struct_definitions = []
    emotion_map = {}  # 表情名 -> 变量名

    for gif_path in sorted(gif_files):
        base_name = os.path.splitext(os.path.basename(gif_path))[0]
        # 跳过 _fixed 等后缀的重复文件
        if '_fixed' in base_name.lower():
            continue

        var_name = base_name.lower().replace('-', '_').replace(' ', '_')

        print(f"处理表情: {gif_path} -> {var_name}")

        c_code, size = gif_to_c_array(gif_path, var_name)
        header_content += c_code + '\n'
        struct_definitions.append((var_name, size))
        emotion_map[var_name] = var_name

    # 生成结构体定义
    header_content += '''
// GIF数据结构体
struct GifData {
    const uint8_t* data;
    size_t data_size;
};

'''

    # 生成各个GIF的结构体实例
    for var_name, size in struct_definitions:
        header_content += f'static const GifData {var_name} = {{ {var_name}_data, {size} }};\n'

    # 生成别名 (兼容原otto_emoji的名称)
    header_content += '\n// 表情别名 (兼容原otto_emoji)\n'
    for alias, target in EMOTION_ALIASES.items():
        if target in emotion_map and alias not in emotion_map:
            header_content += f'static const GifData& {alias} = {target};\n'

    # 写入文件
    os.makedirs(os.path.dirname(output_path), exist_ok=True)
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(header_content)

    print(f"\n成功生成: {output_path}")
    print(f"包含 {len(struct_definitions)} 个表情GIF:")
    total_size = 0
    for var_name, size in struct_definitions:
        print(f"  - {var_name}: {size//1024}KB")
        total_size += size
    print(f"总计: {total_size//1024}KB ({total_size/1024/1024:.1f}MB)")

    return True


def generate_backgrounds_header(gif_dir: str, output_path: str):
    """生成背景GIF头文件"""

    backgrounds_dir = os.path.join(gif_dir, "backgrounds")
    if not os.path.isdir(backgrounds_dir):
        print(f"错误: backgrounds目录不存在 - {backgrounds_dir}")
        return False

    gif_files = glob.glob(os.path.join(backgrounds_dir, "*.gif"))
    gif_files += glob.glob(os.path.join(backgrounds_dir, "*.GIF"))

    if not gif_files:
        print(f"错误: 在 {backgrounds_dir} 中没有找到GIF文件")
        return False

    header_content = '''#pragma once

#include <stdint.h>
#include <stddef.h>

// Auto-generated backgrounds GIF data
// Generated by gif_to_header.py

'''

    struct_definitions = []

    for gif_path in sorted(gif_files):
        base_name = os.path.splitext(os.path.basename(gif_path))[0]
        var_name = "bg_" + base_name.lower().replace('-', '_').replace(' ', '_')

        print(f"处理背景: {gif_path} -> {var_name}")

        c_code, size = gif_to_c_array(gif_path, var_name)
        header_content += c_code + '\n'
        struct_definitions.append((var_name, size))

    # 生成结构体定义
    header_content += '''
// GIF数据结构体
struct GifData {
    const uint8_t* data;
    size_t data_size;
};

// 背景类型枚举
enum class BackgroundType {
    Morning,
    Sunset,
    Night,
    Rainy,
    Christmas,
};

'''

    # 生成各个GIF的结构体实例
    for var_name, size in struct_definitions:
        header_content += f'static const GifData {var_name} = {{ {var_name}_data, {size} }};\n'

    # 写入文件
    os.makedirs(os.path.dirname(output_path), exist_ok=True)
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(header_content)

    print(f"\n成功生成: {output_path}")
    print(f"包含 {len(struct_definitions)} 个背景GIF:")
    total_size = 0
    for var_name, size in struct_definitions:
        print(f"  - {var_name}: {size//1024}KB")
        total_size += size
    print(f"总计: {total_size//1024}KB ({total_size/1024/1024:.1f}MB)")

    return True


def main():
    parser = argparse.ArgumentParser(
        description='将GIF文件转换为C头文件',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=f'''
默认目录结构:
  {DEFAULT_INPUT_DIR}/
  ├── expressions/     <- 表情GIF (透明背景)
  │   ├── Neutral.gif
  │   ├── Happy.gif
  │   └── ...
  └── backgrounds/     <- 背景GIF
      ├── Morning.gif
      ├── Night.gif
      └── ...

输出文件:
  main/boards/otto-robot/otto_emoji_gif.h      (表情)
  main/boards/otto-robot/background_gif.h      (背景)
  main/boards/electron-bot/otto_emoji_gif.h    (表情)
  main/boards/electron-bot/background_gif.h    (背景)

示例:
  python gif_to_header.py                  # 转换所有
  python gif_to_header.py --expressions    # 只转换表情
  python gif_to_header.py --backgrounds    # 只转换背景
'''
    )

    parser.add_argument('-i', '--input', default=DEFAULT_INPUT_DIR,
                        help=f'GIF文件所在目录 (默认: {DEFAULT_INPUT_DIR})')
    parser.add_argument('--expressions', action='store_true',
                        help='只转换expressions表情')
    parser.add_argument('--backgrounds', action='store_true',
                        help='只转换backgrounds背景')

    args = parser.parse_args()

    gif_dir = args.input
    if not os.path.isdir(gif_dir):
        print(f"错误: 输入目录不存在 - {gif_dir}")
        sys.exit(1)

    # 如果没有指定具体类型，则转换所有
    convert_all = not args.expressions and not args.backgrounds

    # 输出目录列表
    output_dirs = [
        os.path.join(DEFAULT_OUTPUT_DIR, "otto-robot"),
        os.path.join(DEFAULT_OUTPUT_DIR, "electron-bot"),
    ]

    print(f"输入目录: {gif_dir}\n")

    success = True

    # 转换表情
    if convert_all or args.expressions:
        print("=" * 50)
        print("转换表情 (expressions)")
        print("=" * 50)
        for output_dir in output_dirs:
            output_path = os.path.join(output_dir, "otto_emoji_gif.h")
            if not generate_expressions_header(gif_dir, output_path):
                success = False
            print()

    # 转换背景
    if convert_all or args.backgrounds:
        print("=" * 50)
        print("转换背景 (backgrounds)")
        print("=" * 50)
        for output_dir in output_dirs:
            output_path = os.path.join(output_dir, "background_gif.h")
            if not generate_backgrounds_header(gif_dir, output_path):
                success = False
            print()

    if success:
        print("全部转换完成!")
    else:
        print("部分转换失败，请检查错误信息")
        sys.exit(1)


if __name__ == '__main__':
    main()
