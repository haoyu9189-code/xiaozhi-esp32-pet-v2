# 内存冲突优化计划

## 问题概述

对话期间，以下系统存在内存和执行冲突：
- 语音聊天（Opus解码器 18KB，音频缓冲）
- 宠物状态机（属性更新，动画切换）
- MCP工具（AI触发的宠物动作）
- 场景物品（金币/便便碰撞检测）

**核心问题**：对话中触发金币拾取 → 音效播放 → 采样率切换 → Opus解码器重建 → 内存碎片化导致分配失败

---

## 第一阶段：紧急修复

### 1.1 延迟NVS写入

**文件**: `main/pet/scene_items.h`, `main/pet/scene_items.cc`

**问题**: 每次金币拾取立即写入NVS（阻塞操作，数百毫秒）

**修改 scene_items.h**:
```cpp
class SceneItemManager {
    // ... 现有成员 ...

    // 添加延迟保存支持
    bool state_dirty_ = false;
    uint32_t last_save_time_ = 0;
    static constexpr uint32_t SAVE_INTERVAL_MS = 30000;  // 30秒保存间隔

public:
    void MarkDirty();           // 标记需要保存
    void SaveIfNeeded();        // 检查并执行延迟保存
    void ForceSave();           // 强制立即保存（关机前调用）
};
```

**修改 scene_items.cc**:
```cpp
void SceneItemManager::MarkDirty() {
    state_dirty_ = true;
}

void SceneItemManager::SaveIfNeeded() {
    if (!state_dirty_) return;

    uint32_t now = esp_timer_get_time() / 1000;
    if (now - last_save_time_ >= SAVE_INTERVAL_MS) {
        Save();
        state_dirty_ = false;
        last_save_time_ = now;
        ESP_LOGI(TAG, "Deferred save completed");
    }
}

void SceneItemManager::ForceSave() {
    if (state_dirty_) {
        Save();
        state_dirty_ = false;
        ESP_LOGI(TAG, "Force save completed");
    }
}

// 修改 OnCoinPickup - 用 MarkDirty() 替换 Save()
void SceneItemManager::OnCoinPickup(int index) {
    // ... 现有逻辑 ...
    MarkDirty();  // 替换原来的 Save();
}

// 修改 OnPoopStep - 用 MarkDirty() 替换 Save()
void SceneItemManager::OnPoopStep(int index) {
    // ... 现有逻辑 ...
    MarkDirty();  // 替换原来的 Save();
}

// 在 Tick() 末尾添加
void SceneItemManager::Tick() {
    // ... 现有逻辑 ...
    SaveIfNeeded();  // 检查是否需要保存
}
```

**修改 application.cc** - 关机前强制保存:
```cpp
// 在 Application 析构或关机处理中
SceneItemManager::GetInstance().ForceSave();
CoinSystem::GetInstance().ForceSave();  // 同样处理
PetStateMachine::GetInstance().ForceSave();
```

---

### 1.2 对话期间禁止金币拾取MCP

**文件**: `main/pet/pet_mcp_tools.cc`

**问题**: AI在对话中调用 `collect_coins` 触发音效，导致采样率切换

**修改 collect_coins 函数**:
```cpp
// 在 collect_coins action="move" 处理中添加检查
if (action == "move") {
    // 检查是否在对话中
    auto& app = Application::GetInstance();
    DeviceState state = app.GetDeviceState();
    if (state == kDeviceStateListening || state == kDeviceStateSpeaking) {
        // 对话中不执行移动捡金币，返回提示
        cJSON* result = cJSON_CreateObject();
        cJSON_AddStringToObject(result, "status", "deferred");
        cJSON_AddStringToObject(result, "message",
            "金币拾取已记录，将在对话结束后执行。请继续对话。");
        char* json_str = cJSON_PrintUnformatted(result);
        std::string response(json_str);
        free(json_str);
        cJSON_Delete(result);
        return response;
    }

    // 原有的移动逻辑...
}
```

**更优雅的方案 - 添加操作队列**:
```cpp
// pet_mcp_tools.cc 顶部添加
struct DeferredOperation {
    std::string action;
    int16_t target_x;
    int16_t target_y;
};
static std::queue<DeferredOperation> deferred_ops_;

// 对话结束时执行（在 Application 中调用）
void ExecuteDeferredOperations() {
    while (!deferred_ops_.empty()) {
        auto& op = deferred_ops_.front();
        // 执行操作...
        deferred_ops_.pop();
    }
}
```

---

### 1.3 Schedule队列限制

**文件**: `main/application.cc`

**问题**: Schedule队列无限增长，可能导致内存溢出

**修改**:
```cpp
// application.h 添加常量
static constexpr size_t MAX_SCHEDULED_TASKS = 32;

// application.cc 修改 Schedule 函数
void Application::Schedule(std::function<void()>&& callback) {
    std::lock_guard<std::mutex> lock(mutex_);

    if (main_tasks_.size() >= MAX_SCHEDULED_TASKS) {
        ESP_LOGW(TAG, "Schedule queue full (%d tasks), dropping oldest",
                 main_tasks_.size());
        main_tasks_.pop_front();  // 丢弃最旧的任务
    }

    main_tasks_.push_back(std::move(callback));
}
```

---

### 1.4 金币拾取不播放音效（对话期间）

**文件**: `main/pet/scene_items.cc`

**问题**: 音效触发采样率切换

**修改 OnCoinPickup**:
```cpp
void SceneItemManager::OnCoinPickup(int index) {
    // ... 现有逻辑 ...

    // 只在空闲状态播放音效
    auto& app = Application::GetInstance();
    if (app.GetDeviceState() == kDeviceStateIdle) {
        app.PlaySound(Lang::Sounds::OGG_SUCCESS);
    }

    // ... 继续处理 ...
}
```

---

## 第二阶段：架构优化

### 2.1 Opus解码器预分配

**文件**: `main/audio/audio_service.h`, `main/audio/audio_service.cc`

**方案**: 预创建两个解码器，避免运行时销毁/重建

```cpp
// audio_service.h
class AudioService {
    // 替换单一解码器
    std::unique_ptr<OpusDecoderWrapper> decoder_16k_;  // 语音（服务器TTS）
    std::unique_ptr<OpusDecoderWrapper> decoder_24k_;  // 本地音效
    OpusDecoderWrapper* active_decoder_ = nullptr;

public:
    void InitDecoders();  // 启动时预创建
    OpusDecoderWrapper* GetDecoder(int sample_rate);
};

// audio_service.cc
void AudioService::InitDecoders() {
    ESP_LOGI(TAG, "Pre-allocating Opus decoders...");
    decoder_16k_ = std::make_unique<OpusDecoderWrapper>(16000, 1, 60);
    decoder_24k_ = std::make_unique<OpusDecoderWrapper>(24000, 1, 60);
    active_decoder_ = decoder_16k_.get();
    ESP_LOGI(TAG, "Decoders ready, total 36KB reserved");
}

OpusDecoderWrapper* AudioService::GetDecoder(int sample_rate) {
    if (sample_rate <= 16000) {
        active_decoder_ = decoder_16k_.get();
    } else {
        active_decoder_ = decoder_24k_.get();
    }
    return active_decoder_;
}

// 修改 SetDecodeSampleRate - 不再销毁重建
void AudioService::SetDecodeSampleRate(int sample_rate, int frame_duration) {
    auto* decoder = GetDecoder(sample_rate);
    if (decoder && decoder->sample_rate() == sample_rate) {
        // 已有匹配的解码器，无需操作
        return;
    }
    // 如果需要不同的帧时长，才重建
    // ...
}
```

---

### 2.2 音频缓冲池化

**文件**: `main/audio/audio_service.h`, `main/audio/audio_service.cc`

**方案**: 预分配固定缓冲，避免每帧分配

```cpp
// audio_service.h
class AudioBufferPool {
    static constexpr size_t BUFFER_SIZE = 2048;  // 足够60ms音频
    static constexpr size_t POOL_SIZE = 4;

    std::array<std::vector<int16_t>, POOL_SIZE> buffers_;
    std::array<bool, POOL_SIZE> in_use_;
    std::mutex mutex_;

public:
    AudioBufferPool() {
        for (auto& buf : buffers_) {
            buf.reserve(BUFFER_SIZE);
        }
        in_use_.fill(false);
    }

    std::vector<int16_t>* Acquire() {
        std::lock_guard<std::mutex> lock(mutex_);
        for (size_t i = 0; i < POOL_SIZE; i++) {
            if (!in_use_[i]) {
                in_use_[i] = true;
                buffers_[i].clear();
                return &buffers_[i];
            }
        }
        ESP_LOGW(TAG, "Buffer pool exhausted!");
        return nullptr;
    }

    void Release(std::vector<int16_t>* buf) {
        std::lock_guard<std::mutex> lock(mutex_);
        for (size_t i = 0; i < POOL_SIZE; i++) {
            if (&buffers_[i] == buf) {
                in_use_[i] = false;
                return;
            }
        }
    }
};
```

---

### 2.3 cJSON静态缓冲

**文件**: `main/pet/pet_mcp_tools.cc`

**问题**: 频繁创建cJSON对象导致堆碎片

**方案**: 使用预分配缓冲
```cpp
// 文件顶部添加静态缓冲
static char json_output_buffer[1024];

// 修改返回JSON的地方
cJSON* result = cJSON_CreateObject();
// ... 构建JSON ...

// 使用预分配缓冲输出
if (!cJSON_PrintPreallocated(result, json_output_buffer,
                              sizeof(json_output_buffer), false)) {
    ESP_LOGE(TAG, "JSON buffer too small!");
}
std::string response(json_output_buffer);
cJSON_Delete(result);
return response;
```

---

## 第三阶段：系统协调

### 3.1 操作调度器

**新文件**: `main/pet/operation_scheduler.h`

```cpp
#pragma once
#include <queue>
#include <functional>

enum class OperationType {
    kImmediate,     // 立即执行（状态查询）
    kDeferred,      // 延迟执行（金币拾取、喂食）
    kExclusive,     // 独占执行（需要音频，如洗澡动画）
};

struct PendingOperation {
    std::function<void()> execute;
    OperationType type;
    const char* name;  // 用于日志
};

class OperationScheduler {
public:
    static OperationScheduler& GetInstance();

    // 提交操作
    bool Submit(PendingOperation op);

    // 检查是否可以执行特定类型操作
    bool CanExecute(OperationType type);

    // 对话结束时调用
    void OnConversationEnd();

    // 每帧调用，处理队列
    void Tick();

private:
    std::queue<PendingOperation> deferred_queue_;
    bool conversation_active_ = false;
};
```

### 3.2 内存监控

**新文件**: `main/utils/memory_monitor.h`

```cpp
#pragma once
#include <esp_heap_caps.h>

class MemoryMonitor {
public:
    // 检查是否可以安全分配指定大小
    static bool CanAllocate(size_t bytes) {
        size_t free = esp_get_free_heap_size();
        size_t largest = heap_caps_get_largest_free_block(MALLOC_CAP_8BIT);

        // 保留20KB安全余量
        return (free > bytes + 20480) && (largest > bytes);
    }

    // 内存警告阈值
    static bool IsLowMemory() {
        return esp_get_free_heap_size() < 40960;  // 40KB
    }

    // 打印内存状态
    static void LogStatus(const char* context) {
        ESP_LOGI("Memory", "[%s] Free: %lu, Largest: %lu",
                 context,
                 esp_get_free_heap_size(),
                 heap_caps_get_largest_free_block(MALLOC_CAP_8BIT));
    }
};
```

---

## 实施检查清单

### 第一阶段（立即可做）
- [ ] 1.1 SceneItemManager 延迟NVS写入
- [ ] 1.2 collect_coins 对话检查
- [ ] 1.3 Schedule队列限制
- [ ] 1.4 金币拾取音效条件播放

### 第二阶段（需要测试）
- [ ] 2.1 Opus解码器预分配
- [ ] 2.2 音频缓冲池化
- [ ] 2.3 cJSON静态缓冲

### 第三阶段（架构改进）
- [ ] 3.1 操作调度器
- [ ] 3.2 内存监控集成

---

## 测试验证

### 场景1：对话中金币拾取
1. 开始对话
2. AI调用 collect_coins
3. 验证：不触发音效，不切换采样率，返回延迟提示

### 场景2：长时间对话
1. 进行5分钟以上对话
2. 监控内存使用
3. 验证：Schedule队列不超过32，内存不持续下降

### 场景3：快速金币拾取
1. 连续拾取多个金币
2. 验证：NVS写入合并，不阻塞主循环

### 场景4：关机数据保存
1. 拾取金币后立即关机
2. 重启验证数据已保存
