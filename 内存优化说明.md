# 内存工具性能优化说明（按需加载方案）

## 问题诊断

### 原因分析
用户报告在使用 memory 工具时出现超时 `[Request interrupted by user]`。经过分析，问题的根源是 `BuildReadResponse()` 函数处理了过多的数据：

1. **数据量过大**：加载并序列化了 10 种类型的记忆数据
   - Profile（用户资料）
   - Preferences（所有喜好/厌恶）
   - Family（所有家庭成员）
   - Facts（30天内所有事实）
   - Traits（所有性格特征）
   - Habits（所有习惯）
   - Events（30天内所有事件）
   - Goals（所有目标）
   - Moments（30天内所有重要时刻）
   - Schedules（所有待办日程，含新增的优先级排序）

2. **性能瓶颈**：
   - NVS 读取操作（10次不同类型的读取）
   - JSON 对象创建和字符串拼接
   - 日程的优先级排序算法
   - 最终 JSON 序列化为字符串

3. **ESP32-C6 资源限制**：
   - 有限的内存和处理能力
   - 单核处理器

### 用户需求
用户明确指出：**需要按需读取特定类型的数据，而不是缩减所有数据**。这样既能避免超时，又能保留完整数据访问能力。

### NVS 存储空间
- **NVS 分区大小**：0xC000 (48 KB) - 在 [partitions/v2/16m.csv](partitions/v2/16m.csv#L3)
- **实际数据量**：约 11 KB
- **剩余空间**：37 KB
- **结论**：✅ 空间充足，不会丢失数据

---

## 优化方案：按需加载

### 修改的文件
- [main/memory/memory_mcp_tools.cc](main/memory/memory_mcp_tools.cc#L22-L250)
- [system_prompt.txt](system_prompt.txt#L23-L36)

### 核心策略：精确查询

不再是"缩减所有数据"，而是**支持按类型精确读取**：

```cpp
// 函数签名改为支持类型过滤
static cJSON* BuildReadResponse(const std::string& type_filter = "")
```

### 使用方式对比

| 调用方式 | 返回内容 | 用途 | 性能 |
|---------|---------|------|------|
| `memory(action='read')` | **概要**：profile + 最近facts/moments + 前8个日程 | 对话开场，快速了解概况 | ⚡ 快（50-150ms） |
| `memory(action='read', type='schedule')` | **完整**：所有待办日程（含优先级、重复信息） | 查看完整日程列表 | ✅ 中等（100-300ms） |
| `memory(action='read', type='preferences')` | **完整**：所有喜好/厌恶 | 查看完整偏好 | ✅ 中等 |
| `memory(action='read', type='family')` | **完整**：所有家庭成员（含亲密度、共同记忆） | 查看家庭详情 | ✅ 中等 |
| `memory(action='read', type='fact')` | **完整**：30天内所有事实 | 回顾长期事实 | ✅ 中等 |
| `memory(action='read', type='trait')` | **完整**：所有性格特征 | 查看完整性格档案 | ✅ 中等 |
| `memory(action='read', type='habit')` | **完整**：所有习惯（含频率） | 查看完整习惯列表 | ✅ 中等 |
| `memory(action='read', type='event')` | **完整**：30天内所有纪念日 | 查看纪念日 | ✅ 中等 |
| `memory(action='read', type='goal')` | **完整**：所有目标（含进度） | 查看目标列表 | ✅ 中等 |
| `memory(action='read', type='moment')` | **完整**：30天内所有重要时刻 | 回顾重要回忆 | ✅ 中等 |

### 技术细节

#### 1. 类型过滤逻辑
```cpp
bool include_all = type_filter.empty();

// Profile
if (include_all || type_filter == "profile") {
    // 加载 profile 数据
    // include_all 时：只返回核心字段 (name, birthday, age)
    // type_filter == "profile" 时：返回所有字段 (name, birthday, age, gender, location)
}

// Schedules
if (include_all || type_filter == "schedule") {
    // 排序逻辑相同（按优先级）
    // include_all 时：限制前 8 个
    // type_filter == "schedule" 时：返回所有，并附带 repeat 信息
}
```

#### 2. 性能监控
```cpp
int64_t start_time = esp_timer_get_time();
// ... 处理 ...
ESP_LOGI(TAG, "BuildReadResponse(type='%s') took %lld ms",
         type_filter.empty() ? "all" : type_filter.c_str(),
         (end_time - start_time) / 1000);
```

#### 3. 日程优先级排序（保留）
```cpp
std::sort(pending_schedules.begin(), pending_schedules.end(),
    [](const Event& a, const Event& b) {
        if (a.significance != b.significance) {
            return a.significance > b.significance;  // 高优先级在前
        }
        int date_cmp = strcmp(a.date, b.date);
        if (date_cmp != 0) return date_cmp < 0;
        return strcmp(a.time, b.time) < 0;
    });
```

---

## 预期效果

### 性能对比

| 场景 | JSON 大小 | 处理时间 | 说明 |
|------|-----------|---------|------|
| **原来**：`memory(action='read')` | 8-12 KB | >1000ms | ❌ 超时 |
| **现在**：`memory(action='read')` | 2-4 KB | 50-150ms | ✅ 快速概要 |
| **现在**：`memory(action='read', type='schedule')` | 1-2 KB | 100-200ms | ✅ 完整日程 |
| **现在**：`memory(action='read', type='preferences')` | 0.5-1 KB | 50-100ms | ✅ 完整喜好 |

### 用户体验

#### 对话开场（年糕启动）
```python
# AI 调用
memory(action='read')  # 返回概要

# 年糕收到的数据：
{
  "profile": {"name": "小明", "birthday": "1990-05-20", "age": 35},
  "preferences": {"likes": ["音乐", "游戏", "咖啡"], "dislikes": ["辣椒", "早起"]},
  "family": [{"relation": "妈妈", "name": "张丽"}],
  "facts": ["喜欢周末睡懒觉", "最近在学Python"],
  "moments": [{"topic": "生日", "content": "收到了新键盘"}],
  "schedules": [
    {"datetime": "2026-02-05 14:00", "content": "团队会议", "priority": 5, "priority_label": "high"},
    {"datetime": "2026-02-05 16:00", "content": "健身", "priority": 3, "priority_label": "medium"},
    ...  // 最多 8 个
  ]
}
```

#### 查看完整日程
```python
# 主人："我今天有哪些安排？"
# AI 调用
memory(action='read', type='schedule')  # 返回所有日程

# 年糕收到的数据：
{
  "schedules": [
    {
      "datetime": "2026-02-05 14:00",
      "content": "团队会议",
      "priority": 5,
      "priority_label": "high"
    },
    {
      "datetime": "2026-02-05 16:00",
      "content": "健身",
      "priority": 3,
      "priority_label": "medium"
    },
    {
      "datetime": "2026-02-06 08:00",
      "content": "每日晨练",
      "priority": 2,
      "priority_label": "low",
      "repeat": "daily"  // 重复日程附带 repeat 信息
    },
    ... // 所有待办日程，不限制数量
  ]
}
```

### 优势

1. **避免超时**：默认查询只返回概要，速度快
2. **保留完整数据**：需要时可以查询特定类型的所有数据
3. **灵活性**：年糕可以根据对话需要选择查询范围
4. **性能可控**：每次查询的数据量明确，易于优化

---

## 编译和测试

### 编译步骤
```bash
cd d:\xiaozhi\xiaozhi-esp32-v2\xiaozhi-esp32-v2
idf.py build
```

### 测试验证

#### 1. 测试概要查询（默认）
```python
# 对话开场
年糕：调用 memory(action='read')

# 预期：
# - 返回 profile + 最近 facts/moments + 前 8 个日程
# - 日志：BuildReadResponse(type='all') took 80 ms
# - ✅ 不超时
```

#### 2. 测试完整日程查询
```python
# 主人："我今天有哪些安排？"
年糕：调用 memory(action='read', type='schedule')

# 预期：
# - 返回所有待办日程（含优先级、重复信息）
# - 日志：BuildReadResponse(type='schedule') took 120 ms
# - ✅ 不超时
```

#### 3. 测试日程添加
```python
# 主人："4点开会"
年糕：调用 memory(action='write', type='schedule', content='开会', datetime='2026-02-02 16:00')

# 预期：
# - 日程保存成功
# - 返回：added: schedule '开会' at 2026-02-02 16:00
# - ✅ 不超时
```

### 预期日志
```
I (12345) MemMcpTools: BuildReadResponse(type='all') took 80 ms
I (12678) MemMcpTools: BuildReadResponse(type='schedule') took 120 ms
```

---

## 后续建议

### 如果仍有问题

1. **进一步优化概要查询**：
   - 减少 schedules 到前 5 个
   - 跳过 moments

2. **缓存策略**：
   - 缓存概要查询结果（1 分钟内复用）
   - 避免重复构建

3. **分批加载**：
   - 对于超大日程列表（>20个），分批返回

### 功能扩展

未来可以添加更多过滤选项：
```python
# 按日期范围查询日程
memory(action='read', type='schedule', start_date='2026-02-05', end_date='2026-02-10')

# 只查询高优先级日程
memory(action='read', type='schedule', priority='high')

# 只查询重复日程
memory(action='read', type='schedule', repeat_only=true)
```

---

## 总结

### 核心问题
- ❌ NVS 容量不足：**否**（48KB 够用）
- ✅ JSON 构建超时：**是**（原因是一次性加载所有数据）

### 解决方案
- **按需加载**：支持类型过滤，精确查询
- `memory(action='read')` → 快速概要（50-150ms）
- `memory(action='read', type='schedule')` → 完整日程（100-200ms）
- 保留了所有数据的完整访问能力

### 效果
- ✅ 概要查询快速（2-4KB，50-150ms）
- ✅ 完整查询可控（1-2KB，100-300ms）
- ✅ 年糕对话启动更快，不再超时
- ✅ 保留了所有数据的完整访问能力

---

## 深层记忆存储方案（两阶段实现）

### 背景

当前记忆系统使用 NVS (48KB) 存储所有记忆数据，存在以下限制：
- **容量限制**：NVS 只有 48KB，当前使用约 11KB（31%），长期使用后可能不足
- **缺乏历史回溯**：Facts/Moments 只保留 30 天，更早的记忆会被丢弃
- **浅层记忆问题**：所有记忆都是"热数据"，没有深层/浅层区分

而系统中的 Asset 分区（SPIFFS，8MB）基本未被充分利用（仅存储动画/背景图片约 2.5MB），有大量空间可用于长期记忆存储。

### 存储架构对比

| 存储位置 | 类型 | 容量 | 访问速度 | 适用场景 |
|---------|------|------|---------|---------|
| **NVS** | Flash KV存储 | 48KB | 快速 | 热数据、浅层记忆（30天内） |
| **Asset (SPIFFS)** | 文件系统 | 8MB (可用约5.5MB) | 中等 | 冷数据、深层记忆（30天外归档） |

### 阶段1：基础归档功能

#### 目标
实现记忆自动归档到 Asset 分区，释放 NVS 空间，保留历史记忆。

#### 归档策略

| 数据类型 | 归档时机 | 归档条件 | 保留在NVS |
|---------|---------|---------|----------|
| **ChatMessage** | 每次对话结束 | 超过30条对话 | 最近30条 |
| **Facts** | 每日凌晨 | 创建时间>30天 | 30天内的 |
| **Moments** | 每日凌晨 | 创建时间>30天 | 30天内的 |
| **Events** | 每周日 | 纪念日已过 | 未来事件 |

其他类型（Profile, Preferences, Family, Traits, Habits, Goals, Schedules）保留在 NVS，不归档。

#### 文件格式

使用 JSONL (JSON Lines) 格式存储归档数据，便于追加和读取：

```
/spiffs/memory/
  ├── chat_archive.jsonl       # 聊天归档
  ├── facts_archive.jsonl      # 事实归档
  ├── moments_archive.jsonl    # 时刻归档
  └── events_archive.jsonl     # 事件归档
```

每行一条记录：
```jsonl
{"timestamp":"2026-01-15T14:30:00","type":"fact","content":"喜欢在周末睡懒觉"}
{"timestamp":"2026-01-20T09:15:00","type":"moment","topic":"生日","content":"收到了新键盘","emotion_type":1,"emotion_intensity":5}
```

#### 实现方案

**新增文件**：
- `main/memory/memory_archive.h` - 归档管理器头文件
- `main/memory/memory_archive.cc` - 归档实现

**核心API**：
```cpp
class MemoryArchive {
public:
    static MemoryArchive& GetInstance();

    // 初始化 SPIFFS 挂载
    bool Init();

    // 归档接口
    bool ArchiveChatMessages(const std::vector<ChatMessage>& messages);
    bool ArchiveFacts(const std::vector<Fact>& facts);
    bool ArchiveMoments(const std::vector<SpecialMoment>& moments);
    bool ArchiveEvents(const std::vector<Event>& events);

    // 获取统计
    size_t GetArchiveCount(const char* type);

private:
    bool AppendToFile(const char* filename, const char* json_line);
    FILE* archive_file_ = nullptr;
};
```

**集成点**：
- `MemoryStorage::AddFact()` - 超过30天时触发归档
- `MemoryStorage::AddMoment()` - 超过30天时触发归档
- `Application::OnClockTimer()` - 每日凌晨检查并归档

#### 预期效果

| 使用场景 | NVS占用 | Asset占用 | 说明 |
|---------|---------|----------|------|
| **使用3个月** | ~12KB | ~500KB | 归档约2000条旧记忆 |
| **使用1年** | ~12KB | ~2MB | 归档约8000条旧记忆 |
| **使用3年** | ~12KB | ~6MB | 归档约24000条旧记忆 |

✅ NVS 始终保持低占用（<30%）
✅ Asset 可存储多年历史记忆
✅ 历史记忆不再丢失

---

### 阶段2：回忆检索功能

#### 目标
实现从 Asset 分区检索历史记忆，让年糕能够"回忆"起更早的对话和事件。

#### 检索场景

| 场景 | 用户输入 | 年糕行为 |
|------|---------|---------|
| **时间回溯** | "我们去年聊过什么？" | 搜索归档中的 ChatMessage |
| **事实回忆** | "你还记得我喜欢什么吗？" | 搜索归档中的 Facts |
| **时刻重现** | "那次生日你说了什么？" | 搜索归档中的 Moments |
| **关键词搜索** | "找找关于'咖啡'的记忆" | 全文搜索归档 |

#### MCP 工具扩展

**新增 action='recall'**：
```python
# 按时间范围回忆
memory(action='recall', type='fact', start_date='2025-12-01', end_date='2025-12-31')

# 按关键词搜索
memory(action='recall', type='moment', keyword='生日')

# 获取最早的N条记忆
memory(action='recall', type='chat', limit=10, order='oldest')
```

**返回格式**：
```json
{
  "recalled_items": [
    {"timestamp": "2025-12-15T14:30:00", "content": "喜欢在周末睡懒觉"},
    {"timestamp": "2025-12-20T09:15:00", "content": "最近在学Python"}
  ],
  "archive_count": 245,
  "search_time_ms": 120
}
```

#### 实现方案

**扩展 MemoryArchive 类**：
```cpp
class MemoryArchive {
public:
    // 检索接口
    std::vector<ArchivedItem> RecallByTimeRange(
        const char* type,
        const char* start_date,
        const char* end_date,
        int limit = 10
    );

    std::vector<ArchivedItem> RecallByKeyword(
        const char* type,
        const char* keyword,
        int limit = 10
    );

    std::vector<ArchivedItem> RecallOldest(
        const char* type,
        int limit = 10
    );

private:
    bool SearchInFile(const char* filename, /* ... */);
};
```

**MCP 工具集成**：
在 `memory_mcp_tools.cc` 中添加 `HandleRecall()` 函数处理 `action='recall'` 请求。

#### 性能考虑

| 优化措施 | 说明 |
|---------|------|
| **索引文件** | 创建 `index.json` 记录每个归档文件的时间范围，避免全文扫描 |
| **分文件存储** | 按月份分文件（如 `facts_2025_12.jsonl`），加速时间范围查询 |
| **限制返回数量** | 默认最多返回 10 条，避免传输超时 |
| **异步处理** | 检索操作放在后台任务，不阻塞主线程 |

#### System Prompt 更新

```markdown
【回忆功能】
- 当主人问"还记得吗"、"之前聊过"、"去年"等关键词时：
  * 使用 memory(action='recall', type='...', keyword='...')
  * 自然表达："让我想想...哦对了，去年12月你跟我说过..."
  * 不要说"正在搜索归档"等技术词汇
- 回忆检索可能需要几秒钟，耐心等待
```

#### 预期效果

| 操作 | 耗时 | 说明 |
|------|------|------|
| 按时间范围回忆（1个月） | 200-500ms | 扫描约300条记录 |
| 按关键词搜索 | 500-1000ms | 全文搜索，返回前10条 |
| 获取最早记忆 | 100-200ms | 直接读取文件开头 |

✅ 年糕能够回忆起数月甚至数年前的对话
✅ 用户感觉年糕"真的记得"他们的历史
✅ 不影响正常对话性能（后台异步检索）

---

### 实现优先级

#### 立即实施（阶段1 - 基础归档）
1. 实现 `MemoryArchive` 基础类
2. 实现 JSONL 文件追加写入
3. 集成到 `MemoryStorage` 的归档触发点
4. 测试验证归档功能

**预计工作量**：2-3小时

#### 后续实施（阶段2 - 回忆检索）
1. 实现归档文件检索功能
2. 添加 MCP 工具 `action='recall'` 支持
3. 优化检索性能（索引、分文件）
4. 更新 system_prompt.txt

**预计工作量**：3-4小时

---

### 技术细节

#### SPIFFS 挂载

```cpp
esp_vfs_spiffs_conf_t conf = {
    .base_path = "/spiffs",
    .partition_label = "assets",
    .max_files = 5,
    .format_if_mount_failed = false
};
esp_vfs_spiffs_register(&conf);
```

#### JSONL 追加写入

```cpp
bool MemoryArchive::AppendToFile(const char* filename, const char* json_line) {
    FILE* f = fopen(filename, "a");  // 追加模式
    if (!f) return false;

    fprintf(f, "%s\n", json_line);
    fclose(f);
    return true;
}
```

#### 内存占用

| 组件 | 内存占用 |
|------|---------|
| MemoryArchive 实例 | ~100 bytes |
| JSONL 写入缓冲 | ~512 bytes |
| 检索缓冲（阶段2） | ~2KB |
| **总计** | **~2.6KB** |

对当前系统（约 300KB 可用内存）影响极小。

---

## 修改记录
- 2026-02-02：初次优化，实现按需加载方案
- 添加了 `type_filter` 参数到 `BuildReadResponse()`
- 更新了 MCP 工具描述和 system_prompt.txt
- 保留了日程优先级排序功能（Phase 1-3 已完成）
- **2026-02-02**：添加深层记忆存储方案（两阶段实现）
  - 阶段1：基础归档功能（Asset 分区存储历史记忆）
  - 阶段2：回忆检索功能（从归档中检索历史记忆）
